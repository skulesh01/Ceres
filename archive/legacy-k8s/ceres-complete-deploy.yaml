---
# ==================== NAMESPACE ====================
apiVersion: v1
kind: Namespace
metadata:
  name: ceres

---
# ==================== CONFIGMAP - КОНФИГУРАЦИЯ ====================
apiVersion: v1
kind: ConfigMap
metadata:
  name: ceres-config
  namespace: ceres
data:
  POSTGRES_PASSWORD: ceres123
  POSTGRES_USER: postgres
  POSTGRES_DB: ceres
  KEYCLOAK_ADMIN: admin
  KEYCLOAK_ADMIN_PASSWORD: admin123
  KEYCLOAK_DB_VENDOR: postgres
  KEYCLOAK_DB_ADDR: postgres
  KEYCLOAK_DB_PORT: "5432"
  KEYCLOAK_DB_DATABASE: ceres
  KEYCLOAK_DB_USER: postgres
  KEYCLOAK_DB_PASSWORD: ceres123
  REDIS_PASSWORD: redis123
  SMTP_HOST: postfix
  SMTP_PORT: "25"
  SMTP_FROM: ceres@company.local

---
# ==================== CONFIGMAP - WG MANAGER CODE ====================
apiVersion: v1
kind: ConfigMap
metadata:
  name: wg-manager-code
  namespace: ceres
data:
  wg-config-manager.py: |
    import os, json, smtplib, requests, logging, subprocess, time
    from datetime import datetime
    from pathlib import Path
    from email.mime.text import MIMEText
    from email.mime.multipart import MIMEMultipart
    from flask import Flask, request, jsonify
    from functools import wraps
    
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    app = Flask(__name__)
    
    class Config:
        KEYCLOAK_URL = os.getenv('KEYCLOAK_URL', 'http://keycloak:8080')
        KEYCLOAK_REALM = os.getenv('KEYCLOAK_REALM', 'master')
        KEYCLOAK_CLIENT = os.getenv('KEYCLOAK_CLIENT_ID', 'admin-cli')
        KEYCLOAK_SECRET = os.getenv('KEYCLOAK_CLIENT_SECRET', 'secret')
        KEYCLOAK_ADMIN = os.getenv('KEYCLOAK_ADMIN', 'admin')
        KEYCLOAK_ADMIN_PASSWORD = os.getenv('KEYCLOAK_ADMIN_PASSWORD', 'admin123')
        SMTP_HOST = os.getenv('SMTP_HOST', 'postfix')
        SMTP_PORT = int(os.getenv('SMTP_PORT', '25'))
        SMTP_FROM = os.getenv('SMTP_FROM', 'ceres@company.local')
        WG_PUBLIC_KEY = os.getenv('WG_PUBLIC_KEY', '')
        WG_ENDPOINT = os.getenv('WG_ENDPOINT', '192.168.1.3:51820')
        CONFIG_STORAGE = '/data/wg-configs'
    
    cfg = Config()
    Path(cfg.CONFIG_STORAGE).mkdir(parents=True, exist_ok=True)
    
    class WireGuardManager:
        def __init__(self, c):
            self.c = c
        
        def generate_keypair(self):
            try:
                privkey = subprocess.check_output(['wg', 'genkey']).decode().strip()
                pubkey = subprocess.check_output(f'echo {privkey} | wg pubkey', shell=True).decode().strip()
                return privkey, pubkey
            except Exception as e:
                logger.error(f"Key gen error: {e}")
                return None, None
        
        def create_user_config(self, username, user_email, client_privkey):
            ip = self._get_next_vpn_ip()
            return f"""[Interface]
    PrivateKey = {client_privkey}
    Address = 10.8.0.{ip}/32
    DNS = 8.8.8.8, 8.8.4.4
    
    [Peer]
    PublicKey = {self.c.WG_PUBLIC_KEY}
    AllowedIPs = 10.8.0.0/24, 192.168.1.0/24
    Endpoint = {self.c.WG_ENDPOINT}
    PersistentKeepalive = 25
    """
        
        def _get_next_vpn_ip(self):
            try:
                ips = set()
                for conf in Path(self.c.CONFIG_STORAGE).glob('*.conf'):
                    with open(conf) as f:
                        content = f.read()
                        if 'Address = 10.8.0.' in content:
                            ip = content.split('Address = 10.8.0.')[1].split('/')[0]
                            try:
                                ips.add(int(ip))
                            except:
                                pass
                return (max(ips) + 1) if ips else 10
            except:
                return 10
    
    class EmailManager:
        def __init__(self, c):
            self.c = c
        
        def send_wg_config(self, email, username, config):
            try:
                msg = MIMEMultipart('alternative')
                msg['Subject'] = f'WireGuard VPN конфиг для {username}'
                msg['From'] = self.c.SMTP_FROM
                msg['To'] = email
                
                text = f"""Здравствуйте, {username}!
    Вашему аккаунту добавлена конфигурация WireGuard VPN.
    
    Инструкции:
    1. Скачайте WireGuard: https://www.wireguard.com/install/
    2. Импортируйте прилагаемый конфиг
    3. Активируйте туннель
    
    С уважением,
    Администрация CERES"""
                
                msg.attach(MIMEText(text, 'plain'))
                
                with smtplib.SMTP(self.c.SMTP_HOST, self.c.SMTP_PORT) as s:
                    s.send_message(msg)
                
                logger.info(f"Email sent to {email}")
                return True
            except Exception as e:
                logger.error(f"Email error: {e}")
                return False
    
    wg = WireGuardManager(cfg)
    email = EmailManager(cfg)
    
    def require_auth(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            token = request.headers.get('Authorization', '').split(' ')[-1]
            if token != os.getenv('API_TOKEN', 'token'):
                return {'error': 'Unauthorized'}, 401
            return f(*args, **kwargs)
        return decorated
    
    @app.route('/health')
    def health():
        return {'status': 'ok'}
    
    @app.route('/api/v1/user/register', methods=['POST'])
    @require_auth
    def register_user():
        try:
            data = request.get_json()
            user_id, username, user_email = data.get('user_id'), data.get('username'), data.get('email')
            
            if not all([user_id, username, user_email]):
                return {'error': 'Missing fields'}, 400
            
            privkey, pubkey = wg.generate_keypair()
            if not privkey:
                return {'error': 'Failed to generate keypair'}, 500
            
            cfg_text = wg.create_user_config(username, user_email, privkey)
            Path(f"{cfg.CONFIG_STORAGE}/{user_id}.conf").write_text(cfg_text)
            
            email.send_wg_config(user_email, username, cfg_text)
            
            metadata = {
                'user_id': user_id, 'username': username, 'email': user_email,
                'public_key': pubkey, 'created_at': datetime.now().isoformat(), 'enabled': True
            }
            Path(f"{cfg.CONFIG_STORAGE}/{user_id}.json").write_text(json.dumps(metadata, indent=2))
            
            return {'status': 'registered', 'message': f'Config sent to {user_email}'}, 201
        except Exception as e:
            logger.error(f"Register error: {e}")
            return {'error': str(e)}, 500
    
    @app.route('/api/v1/user/<user_id>/disable', methods=['POST'])
    @require_auth
    def disable_user(user_id):
        try:
            mf = Path(f"{cfg.CONFIG_STORAGE}/{user_id}.json")
            if not mf.exists():
                return {'error': 'Not found'}, 404
            with open(mf) as f:
                m = json.load(f)
            m['enabled'] = False
            m['disabled_at'] = datetime.now().isoformat()
            mf.write_text(json.dumps(m, indent=2))
            return {'status': 'disabled'}, 200
        except Exception as e:
            return {'error': str(e)}, 500
    
    @app.route('/api/v1/users', methods=['GET'])
    @require_auth
    def list_users():
        try:
            users = []
            for f in Path(cfg.CONFIG_STORAGE).glob('*.json'):
                with open(f) as file:
                    users.append(json.load(file))
            return {'users': users, 'total': len(users)}, 200
        except Exception as e:
            return {'error': str(e)}, 500
    
    if __name__ == '__main__':
        logger.info(f"Starting on port {os.getenv('PORT', '5000')}")
        app.run(host='0.0.0.0', port=int(os.getenv('PORT', '5000')), debug=False)

---
# ==================== CONFIGMAP - POSTFIX ====================
apiVersion: v1
kind: ConfigMap
metadata:
  name: postfix-config
  namespace: ceres
data:
  main.cf: |
    myhostname = ceres.company.local
    mydomain = company.local
    myorigin = $mydomain
    mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain
    inet_interfaces = all
    inet_protocols = ipv4
    mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16

---
# ==================== PERSISTENT VOLUMES ====================
apiVersion: v1
kind: PersistentVolume
metadata:
  name: postgres-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /data/postgres
    type: DirectoryOrCreate

---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: redis-pv
spec:
  capacity:
    storage: 2Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /data/redis
    type: DirectoryOrCreate

---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: keycloak-pv
spec:
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /data/keycloak
    type: DirectoryOrCreate

---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: wg-config-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /data/wg-configs
    type: DirectoryOrCreate

---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: postfix-pv
spec:
  capacity:
    storage: 2Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /data/postfix
    type: DirectoryOrCreate

---
# ==================== PVC ====================
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  namespace: ceres
spec:
  accessModes: [ReadWriteOnce]
  resources:
    requests:
      storage: 10Gi
  volumeName: postgres-pv

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: redis-pvc
  namespace: ceres
spec:
  accessModes: [ReadWriteOnce]
  resources:
    requests:
      storage: 2Gi
  volumeName: redis-pv

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: keycloak-pvc
  namespace: ceres
spec:
  accessModes: [ReadWriteOnce]
  resources:
    requests:
      storage: 5Gi
  volumeName: keycloak-pv

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wg-config-pvc
  namespace: ceres
spec:
  accessModes: [ReadWriteOnce]
  resources:
    requests:
      storage: 1Gi
  volumeName: wg-config-pv

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postfix-pvc
  namespace: ceres
spec:
  accessModes: [ReadWriteOnce]
  resources:
    requests:
      storage: 2Gi
  volumeName: postfix-pv

---
# ==================== POSTGRESQL ====================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  namespace: ceres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        ports: [{containerPort: 5432}]
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            configMapKeyRef:
              name: ceres-config
              key: POSTGRES_PASSWORD
        - name: POSTGRES_USER
          valueFrom:
            configMapKeyRef:
              name: ceres-config
              key: POSTGRES_USER
        - name: POSTGRES_DB
          valueFrom:
            configMapKeyRef:
              name: ceres-config
              key: POSTGRES_DB
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        livenessProbe:
          exec:
            command: [/bin/sh, -c, "pg_isready -U postgres"]
          initialDelaySeconds: 30
          periodSeconds: 10
      volumes:
      - name: postgres-storage
        persistentVolumeClaim:
          claimName: postgres-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: postgres
  namespace: ceres
spec:
  type: ClusterIP
  ports: [{port: 5432, targetPort: 5432}]
  selector:
    app: postgres

---
# ==================== REDIS ====================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: ceres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports: [{containerPort: 6379}]
        command:
        - redis-server
        - "--requirepass"
        - "redis123"
        volumeMounts:
        - name: redis-storage
          mountPath: /data
        livenessProbe:
          exec:
            command: [redis-cli, "-a", "redis123", "ping"]
          initialDelaySeconds: 30
          periodSeconds: 10
      volumes:
      - name: redis-storage
        persistentVolumeClaim:
          claimName: redis-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: ceres
spec:
  type: ClusterIP
  ports: [{port: 6379, targetPort: 6379}]
  selector:
    app: redis

---
# ==================== POSTFIX ====================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postfix
  namespace: ceres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postfix
  template:
    metadata:
      labels:
        app: postfix
    spec:
      containers:
      - name: postfix
        image: boky/postfix:latest
        ports: [{containerPort: 25, name: smtp}]
        env:
        - name: MAILNAME
          value: "ceres.company.local"
        volumeMounts:
        - name: postfix-storage
          mountPath: /var/spool/postfix
        livenessProbe:
          tcpSocket:
            port: 25
          initialDelaySeconds: 30
          periodSeconds: 30
      volumes:
      - name: postfix-storage
        persistentVolumeClaim:
          claimName: postfix-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: postfix
  namespace: ceres
spec:
  type: ClusterIP
  ports: [{port: 25, targetPort: 25}]
  selector:
    app: postfix

---
# ==================== KEYCLOAK ====================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: keycloak
  namespace: ceres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: keycloak
  template:
    metadata:
      labels:
        app: keycloak
    spec:
      containers:
      - name: keycloak
        image: quay.io/keycloak/keycloak:24
        args:
        - "start-dev"
        - "--db=postgres"
        - "--db-url=jdbc:postgresql://postgres:5432/ceres"
        - "--db-username=postgres"
        - "--db-password=ceres123"
        - "--hostname=auth.ceres.local"
        - "--proxy=edge"
        ports: [{containerPort: 8080}]
        env:
        - name: KEYCLOAK_ADMIN
          valueFrom:
            configMapKeyRef:
              name: ceres-config
              key: KEYCLOAK_ADMIN
        - name: KEYCLOAK_ADMIN_PASSWORD
          valueFrom:
            configMapKeyRef:
              name: ceres-config
              key: KEYCLOAK_ADMIN_PASSWORD
        livenessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30

---
apiVersion: v1
kind: Service
metadata:
  name: keycloak
  namespace: ceres
spec:
  type: ClusterIP
  ports: [{port: 8080, targetPort: 8080}]
  selector:
    app: keycloak

---
# ==================== WIREGUARD CONFIG MANAGER ====================
apiVersion: v1
kind: Secret
metadata:
  name: wg-manager-secret
  namespace: ceres
type: Opaque
stringData:
  API_TOKEN: "secure-wg-manager-token-12345"
  WG_PUBLIC_KEY: "zttDeGkGM90yz/yUuP3Ni/jdpF0+Y2rlLKtgMOZda1s="

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wg-config-manager
  namespace: ceres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wg-config-manager
  template:
    metadata:
      labels:
        app: wg-config-manager
    spec:
      containers:
      - name: wg-manager
        image: python:3.11-slim
        workingDir: /app
        command:
        - sh
        - -c
        - pip install -q flask requests && python wg-config-manager.py
        ports: [{containerPort: 5000}]
        env:
        - name: KEYCLOAK_URL
          value: "http://keycloak:8080"
        - name: KEYCLOAK_REALM
          value: "master"
        - name: KEYCLOAK_CLIENT_ID
          value: "admin-cli"
        - name: KEYCLOAK_ADMIN
          value: "admin"
        - name: KEYCLOAK_ADMIN_PASSWORD
          value: "admin123"
        - name: SMTP_HOST
          value: "postfix"
        - name: SMTP_PORT
          value: "25"
        - name: SMTP_FROM
          valueFrom:
            configMapKeyRef:
              name: ceres-config
              key: SMTP_FROM
        - name: WG_ENDPOINT
          value: "192.168.1.3:51820"
        - name: WG_PUBLIC_KEY
          valueFrom:
            secretKeyRef:
              name: wg-manager-secret
              key: WG_PUBLIC_KEY
        - name: API_TOKEN
          valueFrom:
            secretKeyRef:
              name: wg-manager-secret
              key: API_TOKEN
        volumeMounts:
        - name: app-code
          mountPath: /app
        - name: wg-config-storage
          mountPath: /data/wg-configs
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 30
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "500m"
      volumes:
      - name: app-code
        configMap:
          name: wg-manager-code
      - name: wg-config-storage
        persistentVolumeClaim:
          claimName: wg-config-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: wg-config-manager
  namespace: ceres
spec:
  type: ClusterIP
  ports: [{port: 5000, targetPort: 5000}]
  selector:
    app: wg-config-manager

---
# ==================== INGRESS ====================
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ceres-ingress
  namespace: ceres
spec:
  ingressClassName: traefik
  rules:
  - host: auth.ceres.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: keycloak
            port:
              number: 8080
  - host: ceres.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: wg-config-manager
            port:
              number: 5000
